/* SPDX-License-Identifier: MIT and GPLv2 */
// dual licensed just to cover my bases

// temporary dev comments, some to be removed later
/* vGIC setup and initialization for EL1, to run certain proprietary OSes that
   do not support AIC and cannot be made to do so easily.

   Objectives:
        emulate vGIC distributor/redistributors
        redirect virtual interrupts to HW
    
    Apple's vGIC in M1 and M1 v2 has the following characteristics:
        32 levels of virtual priority and virtual preemption priority (5 bits of each)
        16 bits of virtual interrupt ID bits
        SEIs can be generated by the guest
            (hardware bug can result, TODO: update exc. handlers)
        3 level affinity (aff2, aff1, aff0 valid)
        cannot directly inject virtual interrupts (not GICv4)
        no legacy operation
        trap ICV_DIR_EL1 writes to EL2 if configured
        does *not* support extended shared peripheral interrupt ranges (not a GICv3.1)
        8 list registers in the CPU interface

*/

//temporary set of includes, subject to change, from hv.c
#include "hv.h"
#include "assert.h"
#include "cpu_regs.h"
#include "display.h"
#include "memory.h"
#include "pcie.h"
#include "smp.h"
#include "string.h"
#include "usb.h"
#include "utils.h"
#include "malloc.h"
#include "smp.h"
#include "string.h"
#include "types.h"
#include "uartproxy.h"


vgicv3_dist dist;

vgicv3_dist *dist_ptr;

/* Initialization code */

// initializes the vgic registers, maps them to memory 
// (since we're dealing with one VM only)


void vgicv3_init(void)
{
    //set up vGIC struct, set pointer to 0x805570000 (current pre-designated pointer for dist)
    //warning likely dumb idea

    dist_ptr = (vgicv3_dist *)0x805570000;
    memcpy(dist_ptr, &dist, sizeof(vgicv3_dist));
    //clean up leftover from global initialization so that we don't have issues
    memset(&dist, 0, sizeof(vgicv3_dist));
    // likely unnecessary for now
    //mmu_add_mapping(0x805570000, 0x805570000, sizeof(struct vgicv3_distributor), MAIR_IDX_NORMAL, PERM_RWX);

    //set vGIC values to reset
    vgicv3_init_dist_registers();
    //set up ICC_CTLR_EL1 to set virtual interrupts to priority drop only
    int icc_ctlr_sts = 0;
    icc_ctlr_sts = mrs(ICC_CTLR_EL1);
    icc_ctlr_sts |= BIT(1);
    msr(ICC_CTLR_EL1, icc_ctlr_sts);
    
    //initialize CPU interface list registers (we know we have 8)
    for(int i = 0; i++; i < 8)
    {
        vgicv3_init_list_registers(i);
    }
    //final step: enable virtual interrupts
    if(vgicv3_enable_virtual_interrupts())
    {
        printf("enabling virtual interrupts failed!");
        return -1;
    }
    return 0;
}

/* vgicv3_init_dist_registers - sets up reset values for distributor registers
   expected to only be called once
*/

void vgicv3_init_dist_registers(void)
{
    dist_ptr->ctl_register = (BIT(6) | BIT(4) | BIT(1) | BIT(0));
    dist_ptr->type_register = (BIT(22) | BIT(21) | BIT(20) | BIT(19));
    dist_ptr->type_register_2 = 0;
    dist_ptr->err_sts = 0;
    dist_ptr->imp_id_register = (BIT(10) | BIT(5) | BIT(4) | BIT(3) | BIT(1) | BIT(0));
    //set all SPIs to group 1, enable all SPIs
    for(int i = 0; i < 32; i++)
    {
        dist_ptr->interrupt_group_registers[i] = 0xffffffff;
        dist_ptr->interrupt_set_enable_regs[i] = 0xffffffff;
    }

}

/*
* vgicv3_init_list_registers - turns on the list registers
*/
void vgicv3_init_list_registers(int n)
{
    switch(n)
        {
            case 0:
                msr(ICH_LR0_EL2, 0);
            case 1:
                msr(ICH_LR1_EL2, 0);
            case 2:
                msr(ICH_LR2_EL2, 0);
            case 3:
                msr(ICH_LR3_EL2, 0);
            case 4:
                msr(ICH_LR4_EL2, 0);
            case 5:
                msr(ICH_LR5_EL2, 0);
            case 6:
                msr(ICH_LR6_EL2, 0);
            case 7:
                msr(ICH_LR7_EL2, 0);
        }
}

/* vgicv3_enable_virtual_interrupts - enables virtual interrupts on the SoC
   this function is only expected to be called once during vGIC init
   (we're assuming for our purposes the hypervisor will only be used to boot Windows)
*/

// should we also enable TSEI (due to hardware bug)?

int vgicv3_enable_virtual_interrupts(void)
{
    //set VMCR to reset values, then enable virtual group 1 interrupts (aka IRQs)
    //should FIQs also be enabled? not sure how nicely Windows plays with them
    msr(ICH_VMCR_EL2, 0);
    msr(ICH_VMCR_EL2, (BIT(1)));
    //bit 13 sets TSEI (tentatively for now), bit 0 enables the virtual CPU interface registers
    //AMO/IMO/FMO set by m1n1 on boot
    msr(ICH_HCR_EL2, (BIT(13) | BIT(0)));


    return 0;
}



/* Distributor logic */






/* Redistributor logic */