/* SPDX-License-Identifier: MIT */

// temporary dev comments, some to be removed later

/* vGIC setup and initialization for EL1, to assist in running certain proprietary OSes that
   do not support AIC and cannot be made to do so easily.

   Objectives:
        emulate vGIC distributor/redistributors
        redirect virtual interrupts to HW
    
    Apple's vGIC in M1, M1 v2, and M2 has the following characteristics:
        32 levels of virtual priority and virtual preemption priority (5 bits of each)
        16 bits of virtual interrupt ID bits
        SEIs can be generated by the guest
            (hardware bug can result on M1/M1v2, TODO: update exc. handlers)
        3 level affinity (aff2, aff1, aff0 valid)
        cannot directly inject virtual interrupts (not GICv4)
        no legacy operation (not a GICv2 compatible implementation)
        trap ICV_DIR_EL1 writes to EL2 if configured
        does *not* support extended shared peripheral interrupt ranges (not a GICv3.1)
        8 list registers in the CPU interface

    Assumptions:
        There will only be one guest VM running at any given time, so only one set of structs is needed.

*/

//temporary set of includes, subject to change, from hv.c
#include "hv.h"
#include "assert.h"
#include "cpu_regs.h"
#include "display.h"
#include "memory.h"
#include "pcie.h"
#include "smp.h"
#include "string.h"
#include "usb.h"
#include "utils.h"
#include "malloc.h"
#include "smp.h"
#include "string.h"
#include "types.h"
#include "uartproxy.h"


vgicv3_dist dist;

vgicv3_dist *dist_ptr;

/* Initialization code */

// initializes and configures the vgic registers, maps them to memory 
// (since we're dealing with one VM only)


int hv_vgicv3_init(void)
{
    //set up vGIC struct, set pointer to 0x805570000 (current pre-designated pointer for dist)
    //warning likely dumb idea

    dist_ptr = (vgicv3_dist *)0x805570000;
    memcpy(dist_ptr, &dist, sizeof(vgicv3_dist));
    //clean up leftover from global initialization so that
    //memory is again usable by other processes
    memset(&dist, 0, sizeof(vgicv3_dist));

    //set vGIC values to reset
    hv_vgicv3_init_dist_registers();
    //set up ICC_CTLR_EL1 to set virtual interrupts to priority drop only
    int icc_ctlr_sts = 0;
    icc_ctlr_sts = mrs(ICC_CTLR_EL1);
    icc_ctlr_sts |= BIT(1);
    msr(ICC_CTLR_EL1, icc_ctlr_sts);
    
    //initialize CPU interface list registers (we know we have 8)
    for(int i = 0; i++; i < 8)
    {
        vgicv3_init_list_registers(i);
    }
    //final step: enable virtual interrupts
    if(vgicv3_enable_virtual_interrupts())
    {
        printf("enabling virtual interrupts failed!");
        return -1;
    }
    return 0;
}

/* vgicv3_init_dist_registers - sets up reset values for RO/RW distributor registers
   expected to only be called once
   WO registers will be set to 0, but writes will be ignored afterwards
   guest OS will change a lot of these
*/

void hv_vgicv3_init_dist_registers(void)
{
    dist_ptr->ctl_register = (BIT(6) | BIT(4) | BIT(1) | BIT(0));
    dist_ptr->type_register = (BIT(22) | BIT(21) | BIT(20) | BIT(19));
    dist_ptr->type_register_2 = 0;
    dist_ptr->err_sts = 0;
    dist_ptr->imp_id_register = (BIT(10) | BIT(5) | BIT(4) | BIT(3) | BIT(1) | BIT(0));
    //set all SPIs to group 1, disable all SPIs
    for(int i = 0; i < 32; i++)
    {
        dist_ptr->interrupt_group_registers[i] = 0;
        dist_ptr->interrupt_set_enable_regs[i] = 0;
    }

}

/*
* vgicv3_init_list_registers - turns on the list registers
*/
void hv_vgicv3_init_list_registers(int n)
{
    switch(n)
        {
            case 0:
                msr(ICH_LR0_EL2, 0);
            case 1:
                msr(ICH_LR1_EL2, 0);
            case 2:
                msr(ICH_LR2_EL2, 0);
            case 3:
                msr(ICH_LR3_EL2, 0);
            case 4:
                msr(ICH_LR4_EL2, 0);
            case 5:
                msr(ICH_LR5_EL2, 0);
            case 6:
                msr(ICH_LR6_EL2, 0);
            case 7:
                msr(ICH_LR7_EL2, 0);
        }
}

/* vgicv3_enable_virtual_interrupts - enables virtual interrupts on the SoC
   this function is only expected to be called once during vGIC init
   (we're assuming for our purposes the hypervisor will only be used to boot Windows)
*/

int hv_vgicv3_enable_virtual_interrupts(void)
{
    //set VMCR to reset values, then enable virtual group 0 and 1 interrupts
    msr(ICH_VMCR_EL2, 0);
    msr(ICH_VMCR_EL2, (BIT(1)));
    //bit 0 enables the virtual CPU interface registers
    //AMO/IMO/FMO set by m1n1 on boot
    msr(ICH_HCR_EL2, (BIT(0)));


    return 0;
}



/* Distributor logic */






/* Redistributor logic */